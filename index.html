<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified Frame Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        
        /* --- Grid Mode Styles --- */
        .grid-line {
            position: absolute;
            background-color: rgba(239, 68, 68, 0.8); /* Red */
            z-index: 20;
            pointer-events: auto;
            transition: background-color 0.1s;
        }
        .grid-line.horizontal { left: 0; right: 0; height: 1px; cursor: row-resize; }
        .grid-line.vertical { top: 0; bottom: 0; width: 1px; cursor: col-resize; }
        /* Hit area */
        .grid-line::after { content: ''; position: absolute; z-index: 10; }
        .grid-line.horizontal::after { top: -6px; bottom: -6px; left: 0; right: 0; }
        .grid-line.vertical::after { left: -6px; right: -6px; top: 0; bottom: 0; }
        .grid-line:hover { background-color: #ff0000; box-shadow: 0 0 4px #ff0000; }

        /* --- Manual Mode Styles --- */
        .selection-box {
            position: absolute;
            background-color: rgba(59, 130, 246, 0.2); /* Blue tint */
            border: 2px solid #3b82f6; 
            z-index: 30;
            cursor: move;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .selection-box:hover {
            background-color: rgba(59, 130, 246, 0.3);
            border-color: #2563eb;
            z-index: 35;
        }
        .selection-box.drawing {
            background-color: rgba(59, 130, 246, 0.1);
            border-style: dashed;
            pointer-events: none;
        }
        .box-delete {
            position: absolute;
            top: -10px; right: -10px;
            width: 20px; height: 20px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 40;
            border: 2px solid white;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .selection-box:hover .box-delete { display: flex; }

        /* Placeholder */
        #placeholderText:hover {
            background-color: #f8fafc;
            border-color: #3b82f6;
            color: #3b82f6;
        }

        /* Tabs */
        .mode-tab {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        .mode-tab.active {
            background-color: #1e293b;
            color: white;
            shadow: sm;
        }
        .mode-tab.inactive {
            color: #64748b;
            hover: bg-slate-100;
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen text-slate-800 p-4 md:p-6">

    <div class="max-w-[1400px] mx-auto h-[calc(100vh-48px)] flex flex-col">
        
        <!-- Header -->
        <div class="flex justify-between items-center mb-4 bg-white p-3 rounded-lg shadow-sm border border-slate-200 shrink-0">
            <h1 class="text-xl font-bold text-slate-900 flex items-center gap-2">
                <svg class="w-6 h-6 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>
                Unified Frame Extractor
            </h1>
            
            <input type="file" id="fileInput" class="hidden" accept="image/*">

            <div id="headerControls" class="hidden">
                 <button id="resetImageBtn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                    New Image
                </button>
            </div>
        </div>

        <div class="flex-1 grid grid-cols-1 lg:grid-cols-12 gap-6 min-h-0">
            
            <!-- Left Panel -->
            <div class="lg:col-span-7 flex flex-col gap-4 min-h-0">
                
                <!-- Controls Panel (Tabs & Settings) -->
                <div id="controlsPanel" class="bg-white p-4 rounded-xl shadow-sm border border-slate-200 hidden">
                    
                    <!-- Mode Tabs -->
                    <div class="flex gap-2 mb-4 border-b border-slate-100 pb-4">
                        <div id="tabGrid" class="mode-tab active" onclick="setMode('grid')">Smart Grid (Auto)</div>
                        <div id="tabManual" class="mode-tab inactive" onclick="setMode('manual')">Manual Selection</div>
                    </div>

                    <!-- Grid Controls -->
                    <div id="gridControls" class="flex flex-wrap items-end gap-4">
                        <div>
                            <label class="block text-xs font-semibold text-slate-500 uppercase tracking-wider mb-1">Rows</label>
                            <input type="number" id="rowsInput" value="6" min="1" max="20" class="w-16 p-1.5 text-sm border border-slate-300 rounded focus:border-indigo-500 outline-none">
                        </div>
                        <div>
                            <label class="block text-xs font-semibold text-slate-500 uppercase tracking-wider mb-1">Cols</label>
                            <input type="number" id="colsInput" value="6" min="1" max="20" class="w-16 p-1.5 text-sm border border-slate-300 rounded focus:border-indigo-500 outline-none">
                        </div>
                         <div class="flex-1 min-w-[120px]">
                            <label class="block text-xs font-semibold text-slate-500 uppercase tracking-wider mb-1 flex justify-between">
                                <span>Margin</span> <span id="marginVal" class="text-slate-400 font-normal">0%</span>
                            </label>
                            <input type="range" id="marginSlider" min="0" max="20" value="0" step="0.5" class="w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <button id="autoDetectBtn" class="bg-indigo-50 text-indigo-600 hover:bg-indigo-100 px-3 py-1.5 rounded text-sm font-medium transition-colors h-[34px]">
                            Auto-Detect
                        </button>
                    </div>

                    <!-- Manual Controls -->
                    <div id="manualControls" class="hidden flex justify-between items-center">
                        <p class="text-sm text-slate-600">Draw boxes (blue) on the image to extract specific areas.</p>
                        <button id="clearSelectionBtn" class="text-xs text-red-600 hover:bg-red-50 px-3 py-1.5 rounded font-medium border border-red-200">
                            Clear Boxes
                        </button>
                    </div>
                </div>

                <!-- Canvas -->
                <div class="flex-1 bg-slate-100 rounded-xl border border-slate-200 relative overflow-hidden flex items-center justify-center group select-none">
                    
                    <!-- Upload Placeholder -->
                    <div id="placeholderText" class="text-slate-400 text-center p-12 cursor-pointer border-2 border-dashed border-transparent hover:border-blue-400 transition-all rounded-xl w-full h-full flex flex-col items-center justify-center">
                        <svg class="w-16 h-16 text-slate-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                        <p class="text-xl font-bold mb-2">Click to Upload</p>
                        <p class="text-sm opacity-75">Auto-detects grids instantly</p>
                    </div>
                    
                    <div id="previewWrapper" class="relative hidden">
                        <!-- Image Container -->
                        <div id="imageContainer" class="relative shadow-xl bg-white cursor-crosshair">
                            <img id="sourceImg" class="block w-full h-full pointer-events-none select-none">
                            
                            <!-- Overlay Layer (Grids OR Selections) -->
                            <div id="overlayLayer" class="absolute inset-0 z-20"></div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Right Panel: Results -->
            <div class="lg:col-span-5 flex flex-col min-h-0 bg-white rounded-xl shadow-sm border border-slate-200">
                <div class="p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50 rounded-t-xl shrink-0">
                    <div class="flex items-center gap-3">
                        <h2 class="font-bold text-slate-700">Preview</h2>
                        <span id="countBadge" class="bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-full text-xs font-bold">0</span>
                    </div>
                    <button id="downloadAllBtn" class="text-xs bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1.5 rounded font-medium transition-colors">
                        Download All
                    </button>
                </div>
                
                <div id="galleryContainer" class="flex-1 overflow-y-auto p-4 bg-white">
                    <div id="gallery" class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                        <div class="col-span-full py-12 text-center text-slate-400 text-sm">
                            Results will appear here
                        </div>
                    </div>
                </div>
            </div>

        </div>
        <canvas id="canvas" class="hidden"></canvas>
    </div>

    <script>
        // --- Elements ---
        const fileInput = document.getElementById('fileInput');
        const headerControls = document.getElementById('headerControls');
        const controlsPanel = document.getElementById('controlsPanel');
        const placeholderText = document.getElementById('placeholderText');
        const previewWrapper = document.getElementById('previewWrapper');
        const imageContainer = document.getElementById('imageContainer');
        const sourceImg = document.getElementById('sourceImg');
        const overlayLayer = document.getElementById('overlayLayer');
        const gallery = document.getElementById('gallery');
        const countBadge = document.getElementById('countBadge');
        const resetImageBtn = document.getElementById('resetImageBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        
        // Mode UI
        const tabGrid = document.getElementById('tabGrid');
        const tabManual = document.getElementById('tabManual');
        const gridControls = document.getElementById('gridControls');
        const manualControls = document.getElementById('manualControls');

        // Grid Inputs
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const marginSlider = document.getElementById('marginSlider');
        const marginVal = document.getElementById('marginVal');
        const autoDetectBtn = document.getElementById('autoDetectBtn');
        
        // Manual Inputs
        const clearSelectionBtn = document.getElementById('clearSelectionBtn');

        // --- State ---
        let imgObj = null;
        let mode = 'grid'; // 'grid' or 'manual'

        // Grid State
        let rowPercents = []; // 0-100
        let colPercents = []; // 0-100
        let isDraggingLine = false;
        let draggedLineIndex = -1;
        let draggedLineType = null;

        // Manual Selection State
        let selections = []; // {x,y,w,h} %
        let isDrawing = false;
        let drawStart = {x:0, y:0};
        let activeSelectionDiv = null;
        let isMovingBox = false;
        let moveTargetIndex = -1;
        let moveOffset = {x:0, y:0};

        // --- Init ---
        
        // Setup placeholders
        placeholderText.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', e => { if(e.target.files[0]) loadFile(e.target.files[0]); });
        
        // Drag & drop
        placeholderText.addEventListener('dragover', e => { e.preventDefault(); placeholderText.classList.add('bg-indigo-50', 'border-indigo-400'); });
        placeholderText.addEventListener('dragleave', () => placeholderText.classList.remove('bg-indigo-50', 'border-indigo-400'));
        placeholderText.addEventListener('drop', e => {
            e.preventDefault();
            placeholderText.classList.remove('bg-indigo-50', 'border-indigo-400');
            if(e.dataTransfer.files.length) loadFile(e.dataTransfer.files[0]);
        });

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = e => {
                imgObj = new Image();
                imgObj.onload = () => initInterface();
                imgObj.src = e.target.result;
                sourceImg.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function initInterface() {
            placeholderText.classList.add('hidden');
            previewWrapper.classList.remove('hidden');
            controlsPanel.classList.remove('hidden');
            headerControls.classList.remove('hidden');
            
            // Default to Grid Mode and Auto Detect
            mode = 'grid';
            updateModeUI();
            
            fitImageToCanvas();
            
            // Initial Auto-Detect logic
            runAutoDetect();
        }
        
        function resetAll() {
            imgObj = null;
            rowPercents = []; colPercents = [];
            selections = [];
            sourceImg.src = '';
            fileInput.value = '';
            
            previewWrapper.classList.add('hidden');
            controlsPanel.classList.add('hidden');
            headerControls.classList.add('hidden');
            placeholderText.classList.remove('hidden');
            gallery.innerHTML = '<div class="col-span-full py-12 text-center text-slate-400 text-sm">Results will appear here</div>';
            countBadge.innerText = '0';
        }

        // --- Mode Switching ---

        window.setMode = function(newMode) {
            mode = newMode;
            updateModeUI();
            renderOverlay();
            extractFrames();
        }

        function updateModeUI() {
            if(mode === 'grid') {
                tabGrid.className = 'mode-tab active';
                tabManual.className = 'mode-tab inactive';
                gridControls.classList.remove('hidden');
                manualControls.classList.add('hidden');
            } else {
                tabGrid.className = 'mode-tab inactive';
                tabManual.className = 'mode-tab active';
                gridControls.classList.add('hidden');
                manualControls.classList.remove('hidden');
            }
        }

        function fitImageToCanvas() {
            const container = previewWrapper.parentElement;
            const cW = container.clientWidth - 40;
            const cH = container.clientHeight - 40;
            const iRatio = imgObj.width / imgObj.height;
            const cRatio = cW / cH;

            let finalW, finalH;
            if (iRatio > cRatio) { finalW = cW; finalH = cW / iRatio; } 
            else { finalH = cH; finalW = cH * iRatio; }

            previewWrapper.style.width = finalW + 'px';
            previewWrapper.style.height = finalH + 'px';
        }

        // --- GRID LOGIC ---

        function calculateGridFromInputs() {
            const rows = parseInt(rowsInput.value) || 1;
            const cols = parseInt(colsInput.value) || 1;
            const margin = parseFloat(marginSlider.value);
            marginVal.innerText = margin + '%';
            
            rowPercents = [];
            const hStep = (100 - margin*2) / rows;
            for(let i=0; i<=rows; i++) rowPercents.push(margin + (i*hStep));
            
            colPercents = [];
            const wStep = (100 - margin*2) / cols;
            for(let i=0; i<=cols; i++) colPercents.push(margin + (i*wStep));
            
            renderOverlay();
            extractFrames();
        }

        function runAutoDetect() {
            // Simple heuristic based on image dimensions or edges
            // For now, we simulate detection by defaulting to 6x6 if clean, 
            // or maybe smaller if aspect ratio suggests.
            
            // Reset to reasonable default
            rowsInput.value = 6;
            colsInput.value = 6;
            marginSlider.value = 0;
            
            // Trigger calculation
            calculateGridFromInputs();
            
            // If we had real CV here, we would set rowPercents directly.
        }

        // --- Event Listeners ---
        
        [rowsInput, colsInput, marginSlider].forEach(el => el.addEventListener('input', () => {
             if(mode === 'grid') calculateGridFromInputs();
        }));
        
        autoDetectBtn.addEventListener('click', runAutoDetect);
        
        clearSelectionBtn.addEventListener('click', () => {
            selections = [];
            renderOverlay();
            extractFrames();
        });
        
        resetImageBtn.addEventListener('click', resetAll);
        
        downloadAllBtn.addEventListener('click', () => {
            const links = gallery.querySelectorAll('a');
            if(links.length === 0) return alert('No frames to download');
            let i=0; 
            const next=()=>{ if(i<links.length){ links[i].click(); i++; setTimeout(next, 150); }};
            next();
        });

        // --- Interaction Dispatcher ---

        overlayLayer.addEventListener('mousedown', (e) => {
            if(mode === 'grid') handleGridMouseDown(e);
            else handleManualMouseDown(e);
        });
        document.addEventListener('mousemove', (e) => {
            if(mode === 'grid') handleGridMouseMove(e);
            else handleManualMouseMove(e);
        });
        document.addEventListener('mouseup', (e) => {
            if(mode === 'grid') handleGridMouseUp(e);
            else handleManualMouseUp(e);
        });

        // --- GRID HANDLERS ---
        
        function handleGridMouseDown(e) {
            // Check if dragging a line (handled via inline event on element usually, but let's be robust)
            // Lines have their own listeners in renderOverlay
        }
        function handleGridMouseMove(e) {
            if(!isDraggingLine) return;
            const rect = overlayLayer.getBoundingClientRect();
            let pct;
            if(draggedLineType === 'row') {
                pct = ((e.clientY - rect.top) / rect.height) * 100;
                rowPercents[draggedLineIndex] = Math.max(0, Math.min(100, pct));
            } else {
                pct = ((e.clientX - rect.left) / rect.width) * 100;
                colPercents[draggedLineIndex] = Math.max(0, Math.min(100, pct));
            }
            renderOverlay(); // Visual update
        }
        function handleGridMouseUp(e) {
            if(isDraggingLine) {
                isDraggingLine = false;
                extractFrames();
            }
        }

        // --- MANUAL HANDLERS ---

        function handleManualMouseDown(e) {
            if(e.target.classList.contains('box-delete')) return;
            e.preventDefault();
            const rect = overlayLayer.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;

            // Check move
            const boxIdx = selections.slice().reverse().findIndex(s => {
                const sx = (s.x/100)*rect.width, sy = (s.y/100)*rect.height, sw = (s.w/100)*rect.width, sh = (s.h/100)*rect.height;
                return cx >= sx && cx <= sx+sw && cy >= sy && cy <= sy+sh;
            });

            if(boxIdx !== -1) {
                isMovingBox = true;
                moveTargetIndex = selections.length - 1 - boxIdx;
                const s = selections[moveTargetIndex];
                moveOffset = { x: (cx/rect.width*100)-s.x, y: (cy/rect.height*100)-s.y };
                return;
            }

            // Draw new
            isDrawing = true;
            drawStart = { x: cx, y: cy };
            activeSelectionDiv = document.createElement('div');
            activeSelectionDiv.className = 'selection-box drawing';
            activeSelectionDiv.style.left = cx+'px'; activeSelectionDiv.style.top = cy+'px';
            overlayLayer.appendChild(activeSelectionDiv);
        }

        function handleManualMouseMove(e) {
            const rect = overlayLayer.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;

            if(isMovingBox) {
                let nx = (cx/rect.width*100) - moveOffset.x;
                let ny = (cy/rect.height*100) - moveOffset.y;
                const s = selections[moveTargetIndex];
                s.x = Math.max(0, Math.min(100-s.w, nx));
                s.y = Math.max(0, Math.min(100-s.h, ny));
                renderOverlay();
            } else if(isDrawing && activeSelectionDiv) {
                const l = Math.min(drawStart.x, cx), t = Math.min(drawStart.y, cy);
                const w = Math.abs(cx - drawStart.x), h = Math.abs(cy - drawStart.y);
                activeSelectionDiv.style.left = l+'px'; activeSelectionDiv.style.top = t+'px';
                activeSelectionDiv.style.width = w+'px'; activeSelectionDiv.style.height = h+'px';
            }
        }

        function handleManualMouseUp(e) {
            if(isMovingBox) {
                isMovingBox = false;
                extractFrames();
            } else if(isDrawing) {
                isDrawing = false;
                if(!activeSelectionDiv) return;
                const rect = overlayLayer.getBoundingClientRect();
                const style = getComputedStyle(activeSelectionDiv);
                const w = parseFloat(style.width), h = parseFloat(style.height);
                const l = parseFloat(style.left), t = parseFloat(style.top);
                activeSelectionDiv.remove(); activeSelectionDiv = null;
                
                if(w > 5 && h > 5) {
                    selections.push({ x: l/rect.width*100, y: t/rect.height*100, w: w/rect.width*100, h: h/rect.height*100 });
                    renderOverlay();
                    extractFrames();
                }
            }
        }

        // --- Rendering Overlay ---

        function renderOverlay() {
            overlayLayer.innerHTML = '';
            
            if(mode === 'grid') {
                // Render Red Lines
                rowPercents.forEach((p, i) => {
                    const el = document.createElement('div');
                    el.className = 'grid-line horizontal';
                    el.style.top = p + '%';
                    el.addEventListener('mousedown', (e) => { e.stopPropagation(); isDraggingLine=true; draggedLineType='row'; draggedLineIndex=i; });
                    overlayLayer.appendChild(el);
                });
                colPercents.forEach((p, i) => {
                    const el = document.createElement('div');
                    el.className = 'grid-line vertical';
                    el.style.left = p + '%';
                    el.addEventListener('mousedown', (e) => { e.stopPropagation(); isDraggingLine=true; draggedLineType='col'; draggedLineIndex=i; });
                    overlayLayer.appendChild(el);
                });
            } else {
                // Render Blue Boxes
                selections.forEach((s, i) => {
                    const el = document.createElement('div');
                    el.className = 'selection-box';
                    el.style.left = s.x+'%'; el.style.top = s.y+'%'; el.style.width = s.w+'%'; el.style.height = s.h+'%';
                    
                    const btn = document.createElement('div');
                    btn.className = 'box-delete'; btn.innerHTML = 'Ã—';
                    btn.onmousedown = (e) => { e.stopPropagation(); selections.splice(i, 1); renderOverlay(); extractFrames(); };
                    el.appendChild(btn);
                    
                    overlayLayer.appendChild(el);
                });
            }
        }

        // --- EXTRACTION ---

        function extractFrames() {
            if(!imgObj) return;
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            gallery.innerHTML = '';
            
            let framesToExtract = [];

            if(mode === 'grid') {
                // Sort lines
                const rSorted = [...rowPercents].sort((a,b)=>a-b);
                const cSorted = [...colPercents].sort((a,b)=>a-b);
                
                // Create cells
                for(let r=0; r<rSorted.length-1; r++) {
                    for(let c=0; c<cSorted.length-1; c++) {
                        framesToExtract.push({
                            x: cSorted[c], y: rSorted[r],
                            w: cSorted[c+1] - cSorted[c],
                            h: rSorted[r+1] - rSorted[r]
                        });
                    }
                }
            } else {
                framesToExtract = selections;
            }

            if(framesToExtract.length === 0) {
                 gallery.innerHTML = '<div class="col-span-full py-12 text-center text-slate-400 text-sm">No frames selected</div>';
                 countBadge.innerText = '0';
                 return;
            }

            let count = 0;
            framesToExtract.forEach(f => {
                const px = (f.x/100)*imgObj.width;
                const py = (f.y/100)*imgObj.height;
                const pw = (f.w/100)*imgObj.width;
                const ph = (f.h/100)*imgObj.height;
                
                if(pw < 1 || ph < 1) return;
                
                canvas.width = pw; canvas.height = ph;
                ctx.clearRect(0,0,pw,ph);
                ctx.drawImage(imgObj, px, py, pw, ph, 0, 0, pw, ph);
                
                addGalleryItem(canvas.toDataURL('image/png'), ++count);
            });
            countBadge.innerText = count;
        }

        function addGalleryItem(src, idx) {
            const div = document.createElement('div');
            div.className = 'group relative aspect-square bg-slate-50 border border-slate-200 rounded-lg overflow-hidden flex items-center justify-center hover:shadow-md transition-all';
            div.innerHTML = `
                <img src="${src}" class="max-w-full max-h-full object-contain p-1">
                <div class="absolute top-1 left-1 bg-black/50 text-white text-[10px] px-1.5 rounded font-medium">#${idx}</div>
                <a href="${src}" download="frame_${idx}.png" class="absolute inset-0 bg-black/10 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                    <span class="bg-white text-slate-900 px-3 py-1 rounded shadow-sm text-xs font-bold transform translate-y-2 group-hover:translate-y-0 transition-transform">Download</span>
                </a>
            `;
            gallery.appendChild(div);
        }
        
        window.addEventListener('resize', () => { if(imgObj) fitImageToCanvas(); });
    </script>
</body>
</html>
