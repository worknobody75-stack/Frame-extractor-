<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Frame Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .drop-zone {
            border: 2px dashed #cbd5e1;
            transition: all 0.3s ease;
        }
        .drop-zone.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        
        /* Grid Lines */
        .grid-line {
            position: absolute;
            background-color: rgba(239, 68, 68, 0.8);
            z-index: 10;
            transition: background-color 0.2s;
        }
        .grid-line:hover {
            background-color: #ef4444;
            box-shadow: 0 0 4px rgba(239, 68, 68, 0.8);
        }
        .grid-line.horizontal {
            left: 0; right: 0; height: 1px;
            cursor: row-resize;
            /* Invisible touch area */
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            background-clip: padding-box; 
        }
        .grid-line.vertical {
            top: 0; bottom: 0; width: 1px;
            cursor: col-resize;
            /* Invisible touch area */
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            background-clip: padding-box;
        }
        
        .grid-handle {
            position: absolute;
            width: 16px; 
            height: 16px;
            background: #fff;
            border: 2px solid #ef4444;
            border-radius: 50%;
            z-index: 20;
            transform: translate(-50%, -50%);
            display: none; /* Only show on hover/active if needed, keeps UI clean */
        }

        /* Loading Spinner */
        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #3b82f6;
            width: 24px;
            height: 24px;
            -webkit-animation: spin 1s linear infinite; /* Safari */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen text-slate-800 p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="mb-6 flex flex-col md:flex-row justify-between items-end gap-4 border-b border-slate-200 pb-6">
            <div>
                <h1 class="text-3xl font-bold text-slate-900">Pro Frame Extractor</h1>
                <p class="text-slate-600 mt-1">Drag the red lines to slice your image perfectly.</p>
            </div>
            <div id="topControls" class="hidden flex gap-3">
                 <button id="resetGridBtn" class="text-slate-600 hover:text-slate-900 text-sm font-medium px-3 py-2">
                    Reset Grid
                </button>
                <button id="downloadAllBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-sm transition-colors flex items-center gap-2">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    Download All Frames
                </button>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            
            <!-- Left Column: Editor -->
            <div class="lg:col-span-5 space-y-4">
                
                <!-- Upload State -->
                <div id="uploadArea" class="bg-white rounded-xl shadow-sm p-6">
                    <div id="dropZone" class="drop-zone rounded-lg p-12 text-center cursor-pointer relative h-64 flex flex-col items-center justify-center">
                        <input type="file" id="fileInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" accept="image/*">
                        <div class="pointer-events-none">
                            <svg class="w-12 h-12 text-slate-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            <p class="text-lg font-medium text-slate-700">Drop image here</p>
                            <p class="text-sm text-slate-400 mt-1">Supports JPG, PNG</p>
                        </div>
                    </div>
                </div>

                <!-- Editor State (Hidden initially) -->
                <div id="editorArea" class="hidden bg-white rounded-xl shadow-sm p-4 border border-slate-200">
                    
                    <!-- Toolbar -->
                    <div class="flex items-center gap-4 mb-3 pb-3 border-b border-slate-100 text-sm">
                        <div class="flex items-center gap-2">
                            <label class="font-medium text-slate-600">Rows:</label>
                            <input type="number" id="rowsInput" value="6" min="1" max="20" class="w-14 p-1 border rounded text-center">
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="font-medium text-slate-600">Cols:</label>
                            <input type="number" id="colsInput" value="6" min="1" max="20" class="w-14 p-1 border rounded text-center">
                        </div>
                        <button id="applyGridBtn" class="bg-slate-800 text-white px-3 py-1 rounded hover:bg-slate-700 text-xs">Re-Grid</button>
                        <span class="ml-auto text-xs text-slate-400 italic">Drag red lines to adjust</span>
                    </div>

                    <!-- Interactive Preview -->
                    <div class="relative w-full bg-slate-100 rounded border border-slate-300 select-none overflow-hidden touch-none" id="previewWrapper" style="height: 400px;">
                        <div id="imageContainer" class="relative w-full h-full">
                            <!-- Image, Overlay and Lines injected here -->
                        </div>
                    </div>
                    
                </div>
            </div>

            <!-- Right Column: Results Gallery -->
            <div class="lg:col-span-7">
                <div class="bg-white rounded-xl shadow-sm p-6 min-h-[500px] flex flex-col">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="font-bold text-slate-800">Extracted Frames (<span id="countDisplay">0</span>)</h2>
                        <div id="processingIndicator" class="hidden flex items-center gap-2 text-xs text-blue-600 font-medium">
                            <div class="loader"></div>
                            Processing...
                        </div>
                    </div>
                    
                    <div id="gallery" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-3 content-start">
                        <!-- Placeholder -->
                        <div class="col-span-full py-20 text-center text-slate-400 border-2 border-dashed border-slate-100 rounded-xl">
                            Frames will appear here automatically
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Hidden Canvas -->
        <canvas id="canvas" class="hidden"></canvas>
    </div>

    <script>
        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const editorArea = document.getElementById('editorArea');
        const topControls = document.getElementById('topControls');
        const imageContainer = document.getElementById('imageContainer');
        const gallery = document.getElementById('gallery');
        const previewWrapper = document.getElementById('previewWrapper');
        
        // Buttons & Inputs
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const applyGridBtn = document.getElementById('applyGridBtn');
        const resetGridBtn = document.getElementById('resetGridBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const processingIndicator = document.getElementById('processingIndicator');

        // State
        let sourceImage = null;
        let rowPercents = []; // Array of percentages [0, 16.6, 33.3, ... 100]
        let colPercents = []; // Array of percentages
        let draggingLine = null; // { type: 'row'|'col', index: number }
        
        // Debounce for processing to avoid freezing while dragging
        let processTimeout;

        // --- Drag & Drop ---
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('active'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('active'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) handleFile(e.target.files[0]);
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) return alert('Please upload an image.');
            const reader = new FileReader();
            reader.onload = (e) => {
                sourceImage = new Image();
                sourceImage.onload = () => initEditor();
                sourceImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function initEditor() {
            uploadArea.classList.add('hidden');
            editorArea.classList.remove('hidden');
            topControls.classList.remove('hidden');
            
            // Initialize Grid State based on inputs
            generateUniformGrid();
            
            // Initial Render
            renderEditor();
            processFrames();
        }

        function generateUniformGrid() {
            const rows = parseInt(rowsInput.value) || 6;
            const cols = parseInt(colsInput.value) || 6;
            
            rowPercents = [];
            for (let i = 0; i <= rows; i++) rowPercents.push((i / rows) * 100);
            
            colPercents = [];
            for (let i = 0; i <= cols; i++) colPercents.push((i / cols) * 100);
        }

        // --- Editor Rendering ---
        function renderEditor() {
            imageContainer.innerHTML = '';
            
            // Background Image
            const img = document.createElement('img');
            img.src = sourceImage.src;
            img.className = 'absolute top-0 left-0 w-full h-full object-contain';
            img.style.pointerEvents = 'none'; // Click through to container
            imageContainer.appendChild(img);

            // We need to know the actual rendered dimensions of the image to place lines correctly
            // The image is object-contain within 'imageContainer'
            // We'll create a "Grid Layout Box" that sits exactly on top of the visible image pixels
            
            const containerRatio = previewWrapper.clientWidth / previewWrapper.clientHeight;
            const imgRatio = sourceImage.width / sourceImage.height;
            
            let displayW, displayH, displayL, displayT;

            if (imgRatio > containerRatio) {
                displayW = previewWrapper.clientWidth;
                displayH = displayW / imgRatio;
                displayL = 0;
                displayT = (previewWrapper.clientHeight - displayH) / 2;
            } else {
                displayH = previewWrapper.clientHeight;
                displayW = displayH * imgRatio;
                displayT = 0;
                displayL = (previewWrapper.clientWidth - displayW) / 2;
            }

            // Grid Container (This is where lines live)
            const gridBox = document.createElement('div');
            gridBox.style.position = 'absolute';
            gridBox.style.left = `${displayL}px`;
            gridBox.style.top = `${displayT}px`;
            gridBox.style.width = `${displayW}px`;
            gridBox.style.height = `${displayH}px`;
            gridBox.style.boxShadow = '0 0 0 1px rgba(0,0,0,0.1)';
            imageContainer.appendChild(gridBox);

            // Render Rows Lines
            rowPercents.forEach((pct, idx) => {
                const line = document.createElement('div');
                line.className = 'grid-line horizontal';
                line.style.top = `${pct}%`;
                line.dataset.type = 'row';
                line.dataset.index = idx;
                
                // Mouse Events for Dragging
                line.addEventListener('mousedown', startDrag);
                gridBox.appendChild(line);
            });

            // Render Col Lines
            colPercents.forEach((pct, idx) => {
                const line = document.createElement('div');
                line.className = 'grid-line vertical';
                line.style.left = `${pct}%`;
                line.dataset.type = 'col';
                line.dataset.index = idx;

                // Mouse Events for Dragging
                line.addEventListener('mousedown', startDrag);
                gridBox.appendChild(line);
            });
            
            // Store gridBox dimensions for drag calc
            window.gridBoxRect = gridBox.getBoundingClientRect();
        }

        // --- Dragging Logic ---
        function startDrag(e) {
            e.preventDefault();
            const type = e.target.dataset.type;
            const index = parseInt(e.target.dataset.index);
            
            // Prevent dragging first and last lines (0% and 100%) if we want to keep outer bounds fixed?
            // Actually, allowing user to crop is good. Let's allow all.
            
            draggingLine = { type, index };
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            
            // Recalculate rect in case of resize
            // We find the parent gridBox
            window.gridBoxRect = e.target.parentElement.getBoundingClientRect();
        }

        function onDrag(e) {
            if (!draggingLine) return;

            let pct;
            if (draggingLine.type === 'row') {
                const relY = e.clientY - window.gridBoxRect.top;
                pct = (relY / window.gridBoxRect.height) * 100;
                // Clamp
                pct = Math.max(0, Math.min(100, pct));
                rowPercents[draggingLine.index] = pct;
                
                // Sort to keep logical order? No, dragged line should just move. 
                // But if they cross lines, extraction might get weird (negative height).
                // Let's rely on user visually. 
            } else {
                const relX = e.clientX - window.gridBoxRect.left;
                pct = (relX / window.gridBoxRect.width) * 100;
                pct = Math.max(0, Math.min(100, pct));
                colPercents[draggingLine.index] = pct;
            }

            // Visual Update (Fast)
            updateLinePositions();
        }

        function stopDrag() {
            if (draggingLine) {
                draggingLine = null;
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                // Trigger heavy process
                processFrames();
                // Ensure order is correct for extraction logic
                rowPercents.sort((a,b) => a-b);
                colPercents.sort((a,b) => a-b);
                renderEditor(); // Re-render to ensure DOM matches sorted state
            }
        }

        function updateLinePositions() {
            // Locate the specific DOM element and update style
            const typeClass = draggingLine.type === 'row' ? 'horizontal' : 'vertical';
            const prop = draggingLine.type === 'row' ? 'top' : 'left';
            const arr = draggingLine.type === 'row' ? rowPercents : colPercents;
            
            // We need to find the specific line. 
            // Since we didn't store refs, querySelector is fine for this scale
            const lines = document.querySelectorAll(`.grid-line.${typeClass}`);
            // Note: DOM order matches array order initially, but if we don't re-render, 
            // the index in dataset matches the index in our array.
            
            // We find the one with matching dataset index
            const line = Array.from(lines).find(l => parseInt(l.dataset.index) === draggingLine.index);
            if (line) {
                line.style[prop] = `${arr[draggingLine.index]}%`;
            }
        }

        // --- Processing ---
        function processFrames() {
            processingIndicator.classList.remove('hidden');
            
            // Small delay to allow UI to update loading state
            setTimeout(() => {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                
                // We extract based on the intervals defined by rowPercents and colPercents
                // Since they are sorted (mostly), we iterate [i] to [i+1]
                
                gallery.innerHTML = '';
                let count = 0;

                // Ensure sorted
                const sortedRows = [...rowPercents].sort((a,b) => a-b);
                const sortedCols = [...colPercents].sort((a,b) => a-b);

                // We want to make the cards uniform size in the gallery for neatness, 
                // even if extracted frames are variable size. CSS handles that.
                
                // Loop through intervals
                for (let r = 0; r < sortedRows.length - 1; r++) {
                    for (let c = 0; c < sortedCols.length - 1; c++) {
                        const y1 = (sortedRows[r] / 100) * sourceImage.height;
                        const y2 = (sortedRows[r+1] / 100) * sourceImage.height;
                        const x1 = (sortedCols[c] / 100) * sourceImage.width;
                        const x2 = (sortedCols[c+1] / 100) * sourceImage.width;
                        
                        const w = x2 - x1;
                        const h = y2 - y1;

                        if (w <= 1 || h <= 1) continue; // Skip collapsed lines

                        canvas.width = w;
                        canvas.height = h;
                        
                        ctx.drawImage(sourceImage, x1, y1, w, h, 0, 0, w, h);
                        
                        const src = canvas.toDataURL('image/png');
                        addFrameToGallery(src, ++count);
                    }
                }
                
                document.getElementById('countDisplay').innerText = count;
                processingIndicator.classList.add('hidden');
            }, 10);
        }

        function addFrameToGallery(src, index) {
            const div = document.createElement('div');
            div.className = 'bg-white p-2 rounded shadow-sm border border-slate-100 hover:shadow-md transition-all group';
            div.innerHTML = `
                <div class="aspect-square bg-slate-50 mb-2 rounded overflow-hidden flex items-center justify-center relative">
                    <img src="${src}" class="max-w-full max-h-full object-contain">
                </div>
                <div class="flex justify-between items-center px-1">
                    <span class="text-xs font-bold text-slate-400">#${index}</span>
                    <a href="${src}" download="frame_${index}.png" class="text-blue-600 hover:text-blue-800 text-xs font-medium opacity-0 group-hover:opacity-100 transition-opacity">Save</a>
                </div>
            `;
            gallery.appendChild(div);
        }

        // --- Controls Handlers ---
        applyGridBtn.addEventListener('click', () => {
            generateUniformGrid();
            renderEditor();
            processFrames();
        });

        resetGridBtn.addEventListener('click', () => {
            rowsInput.value = 6;
            colsInput.value = 6;
            generateUniformGrid();
            renderEditor();
            processFrames();
        });

        downloadAllBtn.addEventListener('click', () => {
            const imgs = gallery.querySelectorAll('img');
            let count = 0;
            const max = imgs.length;
            
            if(max === 0) return alert('No frames to download');

            // Download loop with delay
            const downloadNext = () => {
                if(count >= max) return;
                
                const img = imgs[count];
                const a = document.createElement('a');
                a.href = img.src;
                a.download = `frame_${count + 1}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                count++;
                setTimeout(downloadNext, 200);
            };
            
            downloadNext();
        });
        
        // Window Resize Handler
        window.addEventListener('resize', () => {
             if(sourceImage) renderEditor(); 
        });

    </script>
</body>
</html>
